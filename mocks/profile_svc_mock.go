// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mock_service

//go:generate minimock -i github.com/gleb-korostelev/GophKeeper/internal/handler.ProfileSvc -o profile_svc_mock.go -n ProfileSvcMock -p mock_service

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gleb-korostelev/GophKeeper/models/profile"
	"github.com/gojuno/minimock/v3"
)

// ProfileSvcMock implements mm_handler.ProfileSvc
type ProfileSvcMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteCard          func(ctx context.Context, username string, cardNumber string) (err error)
	funcDeleteCardOrigin    string
	inspectFuncDeleteCard   func(ctx context.Context, username string, cardNumber string)
	afterDeleteCardCounter  uint64
	beforeDeleteCardCounter uint64
	DeleteCardMock          mProfileSvcMockDeleteCard

	funcGetUserCards          func(ctx context.Context, username string) (ca1 []profile.CardInfo, err error)
	funcGetUserCardsOrigin    string
	inspectFuncGetUserCards   func(ctx context.Context, username string)
	afterGetUserCardsCounter  uint64
	beforeGetUserCardsCounter uint64
	GetUserCardsMock          mProfileSvcMockGetUserCards

	funcUploadInfo          func(ctx context.Context, profile profile.CardInfo) (err error)
	funcUploadInfoOrigin    string
	inspectFuncUploadInfo   func(ctx context.Context, profile profile.CardInfo)
	afterUploadInfoCounter  uint64
	beforeUploadInfoCounter uint64
	UploadInfoMock          mProfileSvcMockUploadInfo
}

// NewProfileSvcMock returns a mock for mm_handler.ProfileSvc
func NewProfileSvcMock(t minimock.Tester) *ProfileSvcMock {
	m := &ProfileSvcMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteCardMock = mProfileSvcMockDeleteCard{mock: m}
	m.DeleteCardMock.callArgs = []*ProfileSvcMockDeleteCardParams{}

	m.GetUserCardsMock = mProfileSvcMockGetUserCards{mock: m}
	m.GetUserCardsMock.callArgs = []*ProfileSvcMockGetUserCardsParams{}

	m.UploadInfoMock = mProfileSvcMockUploadInfo{mock: m}
	m.UploadInfoMock.callArgs = []*ProfileSvcMockUploadInfoParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mProfileSvcMockDeleteCard struct {
	optional           bool
	mock               *ProfileSvcMock
	defaultExpectation *ProfileSvcMockDeleteCardExpectation
	expectations       []*ProfileSvcMockDeleteCardExpectation

	callArgs []*ProfileSvcMockDeleteCardParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProfileSvcMockDeleteCardExpectation specifies expectation struct of the ProfileSvc.DeleteCard
type ProfileSvcMockDeleteCardExpectation struct {
	mock               *ProfileSvcMock
	params             *ProfileSvcMockDeleteCardParams
	paramPtrs          *ProfileSvcMockDeleteCardParamPtrs
	expectationOrigins ProfileSvcMockDeleteCardExpectationOrigins
	results            *ProfileSvcMockDeleteCardResults
	returnOrigin       string
	Counter            uint64
}

// ProfileSvcMockDeleteCardParams contains parameters of the ProfileSvc.DeleteCard
type ProfileSvcMockDeleteCardParams struct {
	ctx        context.Context
	username   string
	cardNumber string
}

// ProfileSvcMockDeleteCardParamPtrs contains pointers to parameters of the ProfileSvc.DeleteCard
type ProfileSvcMockDeleteCardParamPtrs struct {
	ctx        *context.Context
	username   *string
	cardNumber *string
}

// ProfileSvcMockDeleteCardResults contains results of the ProfileSvc.DeleteCard
type ProfileSvcMockDeleteCardResults struct {
	err error
}

// ProfileSvcMockDeleteCardOrigins contains origins of expectations of the ProfileSvc.DeleteCard
type ProfileSvcMockDeleteCardExpectationOrigins struct {
	origin           string
	originCtx        string
	originUsername   string
	originCardNumber string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCard *mProfileSvcMockDeleteCard) Optional() *mProfileSvcMockDeleteCard {
	mmDeleteCard.optional = true
	return mmDeleteCard
}

// Expect sets up expected params for ProfileSvc.DeleteCard
func (mmDeleteCard *mProfileSvcMockDeleteCard) Expect(ctx context.Context, username string, cardNumber string) *mProfileSvcMockDeleteCard {
	if mmDeleteCard.mock.funcDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("ProfileSvcMock.DeleteCard mock is already set by Set")
	}

	if mmDeleteCard.defaultExpectation == nil {
		mmDeleteCard.defaultExpectation = &ProfileSvcMockDeleteCardExpectation{}
	}

	if mmDeleteCard.defaultExpectation.paramPtrs != nil {
		mmDeleteCard.mock.t.Fatalf("ProfileSvcMock.DeleteCard mock is already set by ExpectParams functions")
	}

	mmDeleteCard.defaultExpectation.params = &ProfileSvcMockDeleteCardParams{ctx, username, cardNumber}
	mmDeleteCard.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCard.expectations {
		if minimock.Equal(e.params, mmDeleteCard.defaultExpectation.params) {
			mmDeleteCard.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCard.defaultExpectation.params)
		}
	}

	return mmDeleteCard
}

// ExpectCtxParam1 sets up expected param ctx for ProfileSvc.DeleteCard
func (mmDeleteCard *mProfileSvcMockDeleteCard) ExpectCtxParam1(ctx context.Context) *mProfileSvcMockDeleteCard {
	if mmDeleteCard.mock.funcDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("ProfileSvcMock.DeleteCard mock is already set by Set")
	}

	if mmDeleteCard.defaultExpectation == nil {
		mmDeleteCard.defaultExpectation = &ProfileSvcMockDeleteCardExpectation{}
	}

	if mmDeleteCard.defaultExpectation.params != nil {
		mmDeleteCard.mock.t.Fatalf("ProfileSvcMock.DeleteCard mock is already set by Expect")
	}

	if mmDeleteCard.defaultExpectation.paramPtrs == nil {
		mmDeleteCard.defaultExpectation.paramPtrs = &ProfileSvcMockDeleteCardParamPtrs{}
	}
	mmDeleteCard.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCard.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCard
}

// ExpectUsernameParam2 sets up expected param username for ProfileSvc.DeleteCard
func (mmDeleteCard *mProfileSvcMockDeleteCard) ExpectUsernameParam2(username string) *mProfileSvcMockDeleteCard {
	if mmDeleteCard.mock.funcDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("ProfileSvcMock.DeleteCard mock is already set by Set")
	}

	if mmDeleteCard.defaultExpectation == nil {
		mmDeleteCard.defaultExpectation = &ProfileSvcMockDeleteCardExpectation{}
	}

	if mmDeleteCard.defaultExpectation.params != nil {
		mmDeleteCard.mock.t.Fatalf("ProfileSvcMock.DeleteCard mock is already set by Expect")
	}

	if mmDeleteCard.defaultExpectation.paramPtrs == nil {
		mmDeleteCard.defaultExpectation.paramPtrs = &ProfileSvcMockDeleteCardParamPtrs{}
	}
	mmDeleteCard.defaultExpectation.paramPtrs.username = &username
	mmDeleteCard.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmDeleteCard
}

// ExpectCardNumberParam3 sets up expected param cardNumber for ProfileSvc.DeleteCard
func (mmDeleteCard *mProfileSvcMockDeleteCard) ExpectCardNumberParam3(cardNumber string) *mProfileSvcMockDeleteCard {
	if mmDeleteCard.mock.funcDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("ProfileSvcMock.DeleteCard mock is already set by Set")
	}

	if mmDeleteCard.defaultExpectation == nil {
		mmDeleteCard.defaultExpectation = &ProfileSvcMockDeleteCardExpectation{}
	}

	if mmDeleteCard.defaultExpectation.params != nil {
		mmDeleteCard.mock.t.Fatalf("ProfileSvcMock.DeleteCard mock is already set by Expect")
	}

	if mmDeleteCard.defaultExpectation.paramPtrs == nil {
		mmDeleteCard.defaultExpectation.paramPtrs = &ProfileSvcMockDeleteCardParamPtrs{}
	}
	mmDeleteCard.defaultExpectation.paramPtrs.cardNumber = &cardNumber
	mmDeleteCard.defaultExpectation.expectationOrigins.originCardNumber = minimock.CallerInfo(1)

	return mmDeleteCard
}

// Inspect accepts an inspector function that has same arguments as the ProfileSvc.DeleteCard
func (mmDeleteCard *mProfileSvcMockDeleteCard) Inspect(f func(ctx context.Context, username string, cardNumber string)) *mProfileSvcMockDeleteCard {
	if mmDeleteCard.mock.inspectFuncDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("Inspect function is already set for ProfileSvcMock.DeleteCard")
	}

	mmDeleteCard.mock.inspectFuncDeleteCard = f

	return mmDeleteCard
}

// Return sets up results that will be returned by ProfileSvc.DeleteCard
func (mmDeleteCard *mProfileSvcMockDeleteCard) Return(err error) *ProfileSvcMock {
	if mmDeleteCard.mock.funcDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("ProfileSvcMock.DeleteCard mock is already set by Set")
	}

	if mmDeleteCard.defaultExpectation == nil {
		mmDeleteCard.defaultExpectation = &ProfileSvcMockDeleteCardExpectation{mock: mmDeleteCard.mock}
	}
	mmDeleteCard.defaultExpectation.results = &ProfileSvcMockDeleteCardResults{err}
	mmDeleteCard.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCard.mock
}

// Set uses given function f to mock the ProfileSvc.DeleteCard method
func (mmDeleteCard *mProfileSvcMockDeleteCard) Set(f func(ctx context.Context, username string, cardNumber string) (err error)) *ProfileSvcMock {
	if mmDeleteCard.defaultExpectation != nil {
		mmDeleteCard.mock.t.Fatalf("Default expectation is already set for the ProfileSvc.DeleteCard method")
	}

	if len(mmDeleteCard.expectations) > 0 {
		mmDeleteCard.mock.t.Fatalf("Some expectations are already set for the ProfileSvc.DeleteCard method")
	}

	mmDeleteCard.mock.funcDeleteCard = f
	mmDeleteCard.mock.funcDeleteCardOrigin = minimock.CallerInfo(1)
	return mmDeleteCard.mock
}

// When sets expectation for the ProfileSvc.DeleteCard which will trigger the result defined by the following
// Then helper
func (mmDeleteCard *mProfileSvcMockDeleteCard) When(ctx context.Context, username string, cardNumber string) *ProfileSvcMockDeleteCardExpectation {
	if mmDeleteCard.mock.funcDeleteCard != nil {
		mmDeleteCard.mock.t.Fatalf("ProfileSvcMock.DeleteCard mock is already set by Set")
	}

	expectation := &ProfileSvcMockDeleteCardExpectation{
		mock:               mmDeleteCard.mock,
		params:             &ProfileSvcMockDeleteCardParams{ctx, username, cardNumber},
		expectationOrigins: ProfileSvcMockDeleteCardExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCard.expectations = append(mmDeleteCard.expectations, expectation)
	return expectation
}

// Then sets up ProfileSvc.DeleteCard return parameters for the expectation previously defined by the When method
func (e *ProfileSvcMockDeleteCardExpectation) Then(err error) *ProfileSvcMock {
	e.results = &ProfileSvcMockDeleteCardResults{err}
	return e.mock
}

// Times sets number of times ProfileSvc.DeleteCard should be invoked
func (mmDeleteCard *mProfileSvcMockDeleteCard) Times(n uint64) *mProfileSvcMockDeleteCard {
	if n == 0 {
		mmDeleteCard.mock.t.Fatalf("Times of ProfileSvcMock.DeleteCard mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCard.expectedInvocations, n)
	mmDeleteCard.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCard
}

func (mmDeleteCard *mProfileSvcMockDeleteCard) invocationsDone() bool {
	if len(mmDeleteCard.expectations) == 0 && mmDeleteCard.defaultExpectation == nil && mmDeleteCard.mock.funcDeleteCard == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCard.mock.afterDeleteCardCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCard.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCard implements mm_handler.ProfileSvc
func (mmDeleteCard *ProfileSvcMock) DeleteCard(ctx context.Context, username string, cardNumber string) (err error) {
	mm_atomic.AddUint64(&mmDeleteCard.beforeDeleteCardCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCard.afterDeleteCardCounter, 1)

	mmDeleteCard.t.Helper()

	if mmDeleteCard.inspectFuncDeleteCard != nil {
		mmDeleteCard.inspectFuncDeleteCard(ctx, username, cardNumber)
	}

	mm_params := ProfileSvcMockDeleteCardParams{ctx, username, cardNumber}

	// Record call args
	mmDeleteCard.DeleteCardMock.mutex.Lock()
	mmDeleteCard.DeleteCardMock.callArgs = append(mmDeleteCard.DeleteCardMock.callArgs, &mm_params)
	mmDeleteCard.DeleteCardMock.mutex.Unlock()

	for _, e := range mmDeleteCard.DeleteCardMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCard.DeleteCardMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCard.DeleteCardMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCard.DeleteCardMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCard.DeleteCardMock.defaultExpectation.paramPtrs

		mm_got := ProfileSvcMockDeleteCardParams{ctx, username, cardNumber}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCard.t.Errorf("ProfileSvcMock.DeleteCard got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCard.DeleteCardMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmDeleteCard.t.Errorf("ProfileSvcMock.DeleteCard got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCard.DeleteCardMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.cardNumber != nil && !minimock.Equal(*mm_want_ptrs.cardNumber, mm_got.cardNumber) {
				mmDeleteCard.t.Errorf("ProfileSvcMock.DeleteCard got unexpected parameter cardNumber, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCard.DeleteCardMock.defaultExpectation.expectationOrigins.originCardNumber, *mm_want_ptrs.cardNumber, mm_got.cardNumber, minimock.Diff(*mm_want_ptrs.cardNumber, mm_got.cardNumber))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCard.t.Errorf("ProfileSvcMock.DeleteCard got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCard.DeleteCardMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCard.DeleteCardMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCard.t.Fatal("No results are set for the ProfileSvcMock.DeleteCard")
		}
		return (*mm_results).err
	}
	if mmDeleteCard.funcDeleteCard != nil {
		return mmDeleteCard.funcDeleteCard(ctx, username, cardNumber)
	}
	mmDeleteCard.t.Fatalf("Unexpected call to ProfileSvcMock.DeleteCard. %v %v %v", ctx, username, cardNumber)
	return
}

// DeleteCardAfterCounter returns a count of finished ProfileSvcMock.DeleteCard invocations
func (mmDeleteCard *ProfileSvcMock) DeleteCardAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCard.afterDeleteCardCounter)
}

// DeleteCardBeforeCounter returns a count of ProfileSvcMock.DeleteCard invocations
func (mmDeleteCard *ProfileSvcMock) DeleteCardBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCard.beforeDeleteCardCounter)
}

// Calls returns a list of arguments used in each call to ProfileSvcMock.DeleteCard.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCard *mProfileSvcMockDeleteCard) Calls() []*ProfileSvcMockDeleteCardParams {
	mmDeleteCard.mutex.RLock()

	argCopy := make([]*ProfileSvcMockDeleteCardParams, len(mmDeleteCard.callArgs))
	copy(argCopy, mmDeleteCard.callArgs)

	mmDeleteCard.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCardDone returns true if the count of the DeleteCard invocations corresponds
// the number of defined expectations
func (m *ProfileSvcMock) MinimockDeleteCardDone() bool {
	if m.DeleteCardMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCardMock.invocationsDone()
}

// MinimockDeleteCardInspect logs each unmet expectation
func (m *ProfileSvcMock) MinimockDeleteCardInspect() {
	for _, e := range m.DeleteCardMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProfileSvcMock.DeleteCard at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCardCounter := mm_atomic.LoadUint64(&m.afterDeleteCardCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCardMock.defaultExpectation != nil && afterDeleteCardCounter < 1 {
		if m.DeleteCardMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProfileSvcMock.DeleteCard at\n%s", m.DeleteCardMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProfileSvcMock.DeleteCard at\n%s with params: %#v", m.DeleteCardMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCardMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCard != nil && afterDeleteCardCounter < 1 {
		m.t.Errorf("Expected call to ProfileSvcMock.DeleteCard at\n%s", m.funcDeleteCardOrigin)
	}

	if !m.DeleteCardMock.invocationsDone() && afterDeleteCardCounter > 0 {
		m.t.Errorf("Expected %d calls to ProfileSvcMock.DeleteCard at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCardMock.expectedInvocations), m.DeleteCardMock.expectedInvocationsOrigin, afterDeleteCardCounter)
	}
}

type mProfileSvcMockGetUserCards struct {
	optional           bool
	mock               *ProfileSvcMock
	defaultExpectation *ProfileSvcMockGetUserCardsExpectation
	expectations       []*ProfileSvcMockGetUserCardsExpectation

	callArgs []*ProfileSvcMockGetUserCardsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProfileSvcMockGetUserCardsExpectation specifies expectation struct of the ProfileSvc.GetUserCards
type ProfileSvcMockGetUserCardsExpectation struct {
	mock               *ProfileSvcMock
	params             *ProfileSvcMockGetUserCardsParams
	paramPtrs          *ProfileSvcMockGetUserCardsParamPtrs
	expectationOrigins ProfileSvcMockGetUserCardsExpectationOrigins
	results            *ProfileSvcMockGetUserCardsResults
	returnOrigin       string
	Counter            uint64
}

// ProfileSvcMockGetUserCardsParams contains parameters of the ProfileSvc.GetUserCards
type ProfileSvcMockGetUserCardsParams struct {
	ctx      context.Context
	username string
}

// ProfileSvcMockGetUserCardsParamPtrs contains pointers to parameters of the ProfileSvc.GetUserCards
type ProfileSvcMockGetUserCardsParamPtrs struct {
	ctx      *context.Context
	username *string
}

// ProfileSvcMockGetUserCardsResults contains results of the ProfileSvc.GetUserCards
type ProfileSvcMockGetUserCardsResults struct {
	ca1 []profile.CardInfo
	err error
}

// ProfileSvcMockGetUserCardsOrigins contains origins of expectations of the ProfileSvc.GetUserCards
type ProfileSvcMockGetUserCardsExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserCards *mProfileSvcMockGetUserCards) Optional() *mProfileSvcMockGetUserCards {
	mmGetUserCards.optional = true
	return mmGetUserCards
}

// Expect sets up expected params for ProfileSvc.GetUserCards
func (mmGetUserCards *mProfileSvcMockGetUserCards) Expect(ctx context.Context, username string) *mProfileSvcMockGetUserCards {
	if mmGetUserCards.mock.funcGetUserCards != nil {
		mmGetUserCards.mock.t.Fatalf("ProfileSvcMock.GetUserCards mock is already set by Set")
	}

	if mmGetUserCards.defaultExpectation == nil {
		mmGetUserCards.defaultExpectation = &ProfileSvcMockGetUserCardsExpectation{}
	}

	if mmGetUserCards.defaultExpectation.paramPtrs != nil {
		mmGetUserCards.mock.t.Fatalf("ProfileSvcMock.GetUserCards mock is already set by ExpectParams functions")
	}

	mmGetUserCards.defaultExpectation.params = &ProfileSvcMockGetUserCardsParams{ctx, username}
	mmGetUserCards.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserCards.expectations {
		if minimock.Equal(e.params, mmGetUserCards.defaultExpectation.params) {
			mmGetUserCards.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserCards.defaultExpectation.params)
		}
	}

	return mmGetUserCards
}

// ExpectCtxParam1 sets up expected param ctx for ProfileSvc.GetUserCards
func (mmGetUserCards *mProfileSvcMockGetUserCards) ExpectCtxParam1(ctx context.Context) *mProfileSvcMockGetUserCards {
	if mmGetUserCards.mock.funcGetUserCards != nil {
		mmGetUserCards.mock.t.Fatalf("ProfileSvcMock.GetUserCards mock is already set by Set")
	}

	if mmGetUserCards.defaultExpectation == nil {
		mmGetUserCards.defaultExpectation = &ProfileSvcMockGetUserCardsExpectation{}
	}

	if mmGetUserCards.defaultExpectation.params != nil {
		mmGetUserCards.mock.t.Fatalf("ProfileSvcMock.GetUserCards mock is already set by Expect")
	}

	if mmGetUserCards.defaultExpectation.paramPtrs == nil {
		mmGetUserCards.defaultExpectation.paramPtrs = &ProfileSvcMockGetUserCardsParamPtrs{}
	}
	mmGetUserCards.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserCards.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserCards
}

// ExpectUsernameParam2 sets up expected param username for ProfileSvc.GetUserCards
func (mmGetUserCards *mProfileSvcMockGetUserCards) ExpectUsernameParam2(username string) *mProfileSvcMockGetUserCards {
	if mmGetUserCards.mock.funcGetUserCards != nil {
		mmGetUserCards.mock.t.Fatalf("ProfileSvcMock.GetUserCards mock is already set by Set")
	}

	if mmGetUserCards.defaultExpectation == nil {
		mmGetUserCards.defaultExpectation = &ProfileSvcMockGetUserCardsExpectation{}
	}

	if mmGetUserCards.defaultExpectation.params != nil {
		mmGetUserCards.mock.t.Fatalf("ProfileSvcMock.GetUserCards mock is already set by Expect")
	}

	if mmGetUserCards.defaultExpectation.paramPtrs == nil {
		mmGetUserCards.defaultExpectation.paramPtrs = &ProfileSvcMockGetUserCardsParamPtrs{}
	}
	mmGetUserCards.defaultExpectation.paramPtrs.username = &username
	mmGetUserCards.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUserCards
}

// Inspect accepts an inspector function that has same arguments as the ProfileSvc.GetUserCards
func (mmGetUserCards *mProfileSvcMockGetUserCards) Inspect(f func(ctx context.Context, username string)) *mProfileSvcMockGetUserCards {
	if mmGetUserCards.mock.inspectFuncGetUserCards != nil {
		mmGetUserCards.mock.t.Fatalf("Inspect function is already set for ProfileSvcMock.GetUserCards")
	}

	mmGetUserCards.mock.inspectFuncGetUserCards = f

	return mmGetUserCards
}

// Return sets up results that will be returned by ProfileSvc.GetUserCards
func (mmGetUserCards *mProfileSvcMockGetUserCards) Return(ca1 []profile.CardInfo, err error) *ProfileSvcMock {
	if mmGetUserCards.mock.funcGetUserCards != nil {
		mmGetUserCards.mock.t.Fatalf("ProfileSvcMock.GetUserCards mock is already set by Set")
	}

	if mmGetUserCards.defaultExpectation == nil {
		mmGetUserCards.defaultExpectation = &ProfileSvcMockGetUserCardsExpectation{mock: mmGetUserCards.mock}
	}
	mmGetUserCards.defaultExpectation.results = &ProfileSvcMockGetUserCardsResults{ca1, err}
	mmGetUserCards.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserCards.mock
}

// Set uses given function f to mock the ProfileSvc.GetUserCards method
func (mmGetUserCards *mProfileSvcMockGetUserCards) Set(f func(ctx context.Context, username string) (ca1 []profile.CardInfo, err error)) *ProfileSvcMock {
	if mmGetUserCards.defaultExpectation != nil {
		mmGetUserCards.mock.t.Fatalf("Default expectation is already set for the ProfileSvc.GetUserCards method")
	}

	if len(mmGetUserCards.expectations) > 0 {
		mmGetUserCards.mock.t.Fatalf("Some expectations are already set for the ProfileSvc.GetUserCards method")
	}

	mmGetUserCards.mock.funcGetUserCards = f
	mmGetUserCards.mock.funcGetUserCardsOrigin = minimock.CallerInfo(1)
	return mmGetUserCards.mock
}

// When sets expectation for the ProfileSvc.GetUserCards which will trigger the result defined by the following
// Then helper
func (mmGetUserCards *mProfileSvcMockGetUserCards) When(ctx context.Context, username string) *ProfileSvcMockGetUserCardsExpectation {
	if mmGetUserCards.mock.funcGetUserCards != nil {
		mmGetUserCards.mock.t.Fatalf("ProfileSvcMock.GetUserCards mock is already set by Set")
	}

	expectation := &ProfileSvcMockGetUserCardsExpectation{
		mock:               mmGetUserCards.mock,
		params:             &ProfileSvcMockGetUserCardsParams{ctx, username},
		expectationOrigins: ProfileSvcMockGetUserCardsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserCards.expectations = append(mmGetUserCards.expectations, expectation)
	return expectation
}

// Then sets up ProfileSvc.GetUserCards return parameters for the expectation previously defined by the When method
func (e *ProfileSvcMockGetUserCardsExpectation) Then(ca1 []profile.CardInfo, err error) *ProfileSvcMock {
	e.results = &ProfileSvcMockGetUserCardsResults{ca1, err}
	return e.mock
}

// Times sets number of times ProfileSvc.GetUserCards should be invoked
func (mmGetUserCards *mProfileSvcMockGetUserCards) Times(n uint64) *mProfileSvcMockGetUserCards {
	if n == 0 {
		mmGetUserCards.mock.t.Fatalf("Times of ProfileSvcMock.GetUserCards mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserCards.expectedInvocations, n)
	mmGetUserCards.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserCards
}

func (mmGetUserCards *mProfileSvcMockGetUserCards) invocationsDone() bool {
	if len(mmGetUserCards.expectations) == 0 && mmGetUserCards.defaultExpectation == nil && mmGetUserCards.mock.funcGetUserCards == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserCards.mock.afterGetUserCardsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserCards.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserCards implements mm_handler.ProfileSvc
func (mmGetUserCards *ProfileSvcMock) GetUserCards(ctx context.Context, username string) (ca1 []profile.CardInfo, err error) {
	mm_atomic.AddUint64(&mmGetUserCards.beforeGetUserCardsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserCards.afterGetUserCardsCounter, 1)

	mmGetUserCards.t.Helper()

	if mmGetUserCards.inspectFuncGetUserCards != nil {
		mmGetUserCards.inspectFuncGetUserCards(ctx, username)
	}

	mm_params := ProfileSvcMockGetUserCardsParams{ctx, username}

	// Record call args
	mmGetUserCards.GetUserCardsMock.mutex.Lock()
	mmGetUserCards.GetUserCardsMock.callArgs = append(mmGetUserCards.GetUserCardsMock.callArgs, &mm_params)
	mmGetUserCards.GetUserCardsMock.mutex.Unlock()

	for _, e := range mmGetUserCards.GetUserCardsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetUserCards.GetUserCardsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserCards.GetUserCardsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserCards.GetUserCardsMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserCards.GetUserCardsMock.defaultExpectation.paramPtrs

		mm_got := ProfileSvcMockGetUserCardsParams{ctx, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserCards.t.Errorf("ProfileSvcMock.GetUserCards got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserCards.GetUserCardsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUserCards.t.Errorf("ProfileSvcMock.GetUserCards got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserCards.GetUserCardsMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserCards.t.Errorf("ProfileSvcMock.GetUserCards got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserCards.GetUserCardsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserCards.GetUserCardsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserCards.t.Fatal("No results are set for the ProfileSvcMock.GetUserCards")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetUserCards.funcGetUserCards != nil {
		return mmGetUserCards.funcGetUserCards(ctx, username)
	}
	mmGetUserCards.t.Fatalf("Unexpected call to ProfileSvcMock.GetUserCards. %v %v", ctx, username)
	return
}

// GetUserCardsAfterCounter returns a count of finished ProfileSvcMock.GetUserCards invocations
func (mmGetUserCards *ProfileSvcMock) GetUserCardsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserCards.afterGetUserCardsCounter)
}

// GetUserCardsBeforeCounter returns a count of ProfileSvcMock.GetUserCards invocations
func (mmGetUserCards *ProfileSvcMock) GetUserCardsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserCards.beforeGetUserCardsCounter)
}

// Calls returns a list of arguments used in each call to ProfileSvcMock.GetUserCards.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserCards *mProfileSvcMockGetUserCards) Calls() []*ProfileSvcMockGetUserCardsParams {
	mmGetUserCards.mutex.RLock()

	argCopy := make([]*ProfileSvcMockGetUserCardsParams, len(mmGetUserCards.callArgs))
	copy(argCopy, mmGetUserCards.callArgs)

	mmGetUserCards.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserCardsDone returns true if the count of the GetUserCards invocations corresponds
// the number of defined expectations
func (m *ProfileSvcMock) MinimockGetUserCardsDone() bool {
	if m.GetUserCardsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserCardsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserCardsMock.invocationsDone()
}

// MinimockGetUserCardsInspect logs each unmet expectation
func (m *ProfileSvcMock) MinimockGetUserCardsInspect() {
	for _, e := range m.GetUserCardsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProfileSvcMock.GetUserCards at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCardsCounter := mm_atomic.LoadUint64(&m.afterGetUserCardsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserCardsMock.defaultExpectation != nil && afterGetUserCardsCounter < 1 {
		if m.GetUserCardsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProfileSvcMock.GetUserCards at\n%s", m.GetUserCardsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProfileSvcMock.GetUserCards at\n%s with params: %#v", m.GetUserCardsMock.defaultExpectation.expectationOrigins.origin, *m.GetUserCardsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserCards != nil && afterGetUserCardsCounter < 1 {
		m.t.Errorf("Expected call to ProfileSvcMock.GetUserCards at\n%s", m.funcGetUserCardsOrigin)
	}

	if !m.GetUserCardsMock.invocationsDone() && afterGetUserCardsCounter > 0 {
		m.t.Errorf("Expected %d calls to ProfileSvcMock.GetUserCards at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserCardsMock.expectedInvocations), m.GetUserCardsMock.expectedInvocationsOrigin, afterGetUserCardsCounter)
	}
}

type mProfileSvcMockUploadInfo struct {
	optional           bool
	mock               *ProfileSvcMock
	defaultExpectation *ProfileSvcMockUploadInfoExpectation
	expectations       []*ProfileSvcMockUploadInfoExpectation

	callArgs []*ProfileSvcMockUploadInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProfileSvcMockUploadInfoExpectation specifies expectation struct of the ProfileSvc.UploadInfo
type ProfileSvcMockUploadInfoExpectation struct {
	mock               *ProfileSvcMock
	params             *ProfileSvcMockUploadInfoParams
	paramPtrs          *ProfileSvcMockUploadInfoParamPtrs
	expectationOrigins ProfileSvcMockUploadInfoExpectationOrigins
	results            *ProfileSvcMockUploadInfoResults
	returnOrigin       string
	Counter            uint64
}

// ProfileSvcMockUploadInfoParams contains parameters of the ProfileSvc.UploadInfo
type ProfileSvcMockUploadInfoParams struct {
	ctx     context.Context
	profile profile.CardInfo
}

// ProfileSvcMockUploadInfoParamPtrs contains pointers to parameters of the ProfileSvc.UploadInfo
type ProfileSvcMockUploadInfoParamPtrs struct {
	ctx     *context.Context
	profile *profile.CardInfo
}

// ProfileSvcMockUploadInfoResults contains results of the ProfileSvc.UploadInfo
type ProfileSvcMockUploadInfoResults struct {
	err error
}

// ProfileSvcMockUploadInfoOrigins contains origins of expectations of the ProfileSvc.UploadInfo
type ProfileSvcMockUploadInfoExpectationOrigins struct {
	origin        string
	originCtx     string
	originProfile string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadInfo *mProfileSvcMockUploadInfo) Optional() *mProfileSvcMockUploadInfo {
	mmUploadInfo.optional = true
	return mmUploadInfo
}

// Expect sets up expected params for ProfileSvc.UploadInfo
func (mmUploadInfo *mProfileSvcMockUploadInfo) Expect(ctx context.Context, profile profile.CardInfo) *mProfileSvcMockUploadInfo {
	if mmUploadInfo.mock.funcUploadInfo != nil {
		mmUploadInfo.mock.t.Fatalf("ProfileSvcMock.UploadInfo mock is already set by Set")
	}

	if mmUploadInfo.defaultExpectation == nil {
		mmUploadInfo.defaultExpectation = &ProfileSvcMockUploadInfoExpectation{}
	}

	if mmUploadInfo.defaultExpectation.paramPtrs != nil {
		mmUploadInfo.mock.t.Fatalf("ProfileSvcMock.UploadInfo mock is already set by ExpectParams functions")
	}

	mmUploadInfo.defaultExpectation.params = &ProfileSvcMockUploadInfoParams{ctx, profile}
	mmUploadInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadInfo.expectations {
		if minimock.Equal(e.params, mmUploadInfo.defaultExpectation.params) {
			mmUploadInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadInfo.defaultExpectation.params)
		}
	}

	return mmUploadInfo
}

// ExpectCtxParam1 sets up expected param ctx for ProfileSvc.UploadInfo
func (mmUploadInfo *mProfileSvcMockUploadInfo) ExpectCtxParam1(ctx context.Context) *mProfileSvcMockUploadInfo {
	if mmUploadInfo.mock.funcUploadInfo != nil {
		mmUploadInfo.mock.t.Fatalf("ProfileSvcMock.UploadInfo mock is already set by Set")
	}

	if mmUploadInfo.defaultExpectation == nil {
		mmUploadInfo.defaultExpectation = &ProfileSvcMockUploadInfoExpectation{}
	}

	if mmUploadInfo.defaultExpectation.params != nil {
		mmUploadInfo.mock.t.Fatalf("ProfileSvcMock.UploadInfo mock is already set by Expect")
	}

	if mmUploadInfo.defaultExpectation.paramPtrs == nil {
		mmUploadInfo.defaultExpectation.paramPtrs = &ProfileSvcMockUploadInfoParamPtrs{}
	}
	mmUploadInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadInfo
}

// ExpectProfileParam2 sets up expected param profile for ProfileSvc.UploadInfo
func (mmUploadInfo *mProfileSvcMockUploadInfo) ExpectProfileParam2(profile profile.CardInfo) *mProfileSvcMockUploadInfo {
	if mmUploadInfo.mock.funcUploadInfo != nil {
		mmUploadInfo.mock.t.Fatalf("ProfileSvcMock.UploadInfo mock is already set by Set")
	}

	if mmUploadInfo.defaultExpectation == nil {
		mmUploadInfo.defaultExpectation = &ProfileSvcMockUploadInfoExpectation{}
	}

	if mmUploadInfo.defaultExpectation.params != nil {
		mmUploadInfo.mock.t.Fatalf("ProfileSvcMock.UploadInfo mock is already set by Expect")
	}

	if mmUploadInfo.defaultExpectation.paramPtrs == nil {
		mmUploadInfo.defaultExpectation.paramPtrs = &ProfileSvcMockUploadInfoParamPtrs{}
	}
	mmUploadInfo.defaultExpectation.paramPtrs.profile = &profile
	mmUploadInfo.defaultExpectation.expectationOrigins.originProfile = minimock.CallerInfo(1)

	return mmUploadInfo
}

// Inspect accepts an inspector function that has same arguments as the ProfileSvc.UploadInfo
func (mmUploadInfo *mProfileSvcMockUploadInfo) Inspect(f func(ctx context.Context, profile profile.CardInfo)) *mProfileSvcMockUploadInfo {
	if mmUploadInfo.mock.inspectFuncUploadInfo != nil {
		mmUploadInfo.mock.t.Fatalf("Inspect function is already set for ProfileSvcMock.UploadInfo")
	}

	mmUploadInfo.mock.inspectFuncUploadInfo = f

	return mmUploadInfo
}

// Return sets up results that will be returned by ProfileSvc.UploadInfo
func (mmUploadInfo *mProfileSvcMockUploadInfo) Return(err error) *ProfileSvcMock {
	if mmUploadInfo.mock.funcUploadInfo != nil {
		mmUploadInfo.mock.t.Fatalf("ProfileSvcMock.UploadInfo mock is already set by Set")
	}

	if mmUploadInfo.defaultExpectation == nil {
		mmUploadInfo.defaultExpectation = &ProfileSvcMockUploadInfoExpectation{mock: mmUploadInfo.mock}
	}
	mmUploadInfo.defaultExpectation.results = &ProfileSvcMockUploadInfoResults{err}
	mmUploadInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadInfo.mock
}

// Set uses given function f to mock the ProfileSvc.UploadInfo method
func (mmUploadInfo *mProfileSvcMockUploadInfo) Set(f func(ctx context.Context, profile profile.CardInfo) (err error)) *ProfileSvcMock {
	if mmUploadInfo.defaultExpectation != nil {
		mmUploadInfo.mock.t.Fatalf("Default expectation is already set for the ProfileSvc.UploadInfo method")
	}

	if len(mmUploadInfo.expectations) > 0 {
		mmUploadInfo.mock.t.Fatalf("Some expectations are already set for the ProfileSvc.UploadInfo method")
	}

	mmUploadInfo.mock.funcUploadInfo = f
	mmUploadInfo.mock.funcUploadInfoOrigin = minimock.CallerInfo(1)
	return mmUploadInfo.mock
}

// When sets expectation for the ProfileSvc.UploadInfo which will trigger the result defined by the following
// Then helper
func (mmUploadInfo *mProfileSvcMockUploadInfo) When(ctx context.Context, profile profile.CardInfo) *ProfileSvcMockUploadInfoExpectation {
	if mmUploadInfo.mock.funcUploadInfo != nil {
		mmUploadInfo.mock.t.Fatalf("ProfileSvcMock.UploadInfo mock is already set by Set")
	}

	expectation := &ProfileSvcMockUploadInfoExpectation{
		mock:               mmUploadInfo.mock,
		params:             &ProfileSvcMockUploadInfoParams{ctx, profile},
		expectationOrigins: ProfileSvcMockUploadInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadInfo.expectations = append(mmUploadInfo.expectations, expectation)
	return expectation
}

// Then sets up ProfileSvc.UploadInfo return parameters for the expectation previously defined by the When method
func (e *ProfileSvcMockUploadInfoExpectation) Then(err error) *ProfileSvcMock {
	e.results = &ProfileSvcMockUploadInfoResults{err}
	return e.mock
}

// Times sets number of times ProfileSvc.UploadInfo should be invoked
func (mmUploadInfo *mProfileSvcMockUploadInfo) Times(n uint64) *mProfileSvcMockUploadInfo {
	if n == 0 {
		mmUploadInfo.mock.t.Fatalf("Times of ProfileSvcMock.UploadInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadInfo.expectedInvocations, n)
	mmUploadInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadInfo
}

func (mmUploadInfo *mProfileSvcMockUploadInfo) invocationsDone() bool {
	if len(mmUploadInfo.expectations) == 0 && mmUploadInfo.defaultExpectation == nil && mmUploadInfo.mock.funcUploadInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadInfo.mock.afterUploadInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadInfo implements mm_handler.ProfileSvc
func (mmUploadInfo *ProfileSvcMock) UploadInfo(ctx context.Context, profile profile.CardInfo) (err error) {
	mm_atomic.AddUint64(&mmUploadInfo.beforeUploadInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadInfo.afterUploadInfoCounter, 1)

	mmUploadInfo.t.Helper()

	if mmUploadInfo.inspectFuncUploadInfo != nil {
		mmUploadInfo.inspectFuncUploadInfo(ctx, profile)
	}

	mm_params := ProfileSvcMockUploadInfoParams{ctx, profile}

	// Record call args
	mmUploadInfo.UploadInfoMock.mutex.Lock()
	mmUploadInfo.UploadInfoMock.callArgs = append(mmUploadInfo.UploadInfoMock.callArgs, &mm_params)
	mmUploadInfo.UploadInfoMock.mutex.Unlock()

	for _, e := range mmUploadInfo.UploadInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUploadInfo.UploadInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadInfo.UploadInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadInfo.UploadInfoMock.defaultExpectation.params
		mm_want_ptrs := mmUploadInfo.UploadInfoMock.defaultExpectation.paramPtrs

		mm_got := ProfileSvcMockUploadInfoParams{ctx, profile}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadInfo.t.Errorf("ProfileSvcMock.UploadInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadInfo.UploadInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.profile != nil && !minimock.Equal(*mm_want_ptrs.profile, mm_got.profile) {
				mmUploadInfo.t.Errorf("ProfileSvcMock.UploadInfo got unexpected parameter profile, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadInfo.UploadInfoMock.defaultExpectation.expectationOrigins.originProfile, *mm_want_ptrs.profile, mm_got.profile, minimock.Diff(*mm_want_ptrs.profile, mm_got.profile))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadInfo.t.Errorf("ProfileSvcMock.UploadInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadInfo.UploadInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadInfo.UploadInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadInfo.t.Fatal("No results are set for the ProfileSvcMock.UploadInfo")
		}
		return (*mm_results).err
	}
	if mmUploadInfo.funcUploadInfo != nil {
		return mmUploadInfo.funcUploadInfo(ctx, profile)
	}
	mmUploadInfo.t.Fatalf("Unexpected call to ProfileSvcMock.UploadInfo. %v %v", ctx, profile)
	return
}

// UploadInfoAfterCounter returns a count of finished ProfileSvcMock.UploadInfo invocations
func (mmUploadInfo *ProfileSvcMock) UploadInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadInfo.afterUploadInfoCounter)
}

// UploadInfoBeforeCounter returns a count of ProfileSvcMock.UploadInfo invocations
func (mmUploadInfo *ProfileSvcMock) UploadInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadInfo.beforeUploadInfoCounter)
}

// Calls returns a list of arguments used in each call to ProfileSvcMock.UploadInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadInfo *mProfileSvcMockUploadInfo) Calls() []*ProfileSvcMockUploadInfoParams {
	mmUploadInfo.mutex.RLock()

	argCopy := make([]*ProfileSvcMockUploadInfoParams, len(mmUploadInfo.callArgs))
	copy(argCopy, mmUploadInfo.callArgs)

	mmUploadInfo.mutex.RUnlock()

	return argCopy
}

// MinimockUploadInfoDone returns true if the count of the UploadInfo invocations corresponds
// the number of defined expectations
func (m *ProfileSvcMock) MinimockUploadInfoDone() bool {
	if m.UploadInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadInfoMock.invocationsDone()
}

// MinimockUploadInfoInspect logs each unmet expectation
func (m *ProfileSvcMock) MinimockUploadInfoInspect() {
	for _, e := range m.UploadInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProfileSvcMock.UploadInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadInfoCounter := mm_atomic.LoadUint64(&m.afterUploadInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadInfoMock.defaultExpectation != nil && afterUploadInfoCounter < 1 {
		if m.UploadInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProfileSvcMock.UploadInfo at\n%s", m.UploadInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProfileSvcMock.UploadInfo at\n%s with params: %#v", m.UploadInfoMock.defaultExpectation.expectationOrigins.origin, *m.UploadInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadInfo != nil && afterUploadInfoCounter < 1 {
		m.t.Errorf("Expected call to ProfileSvcMock.UploadInfo at\n%s", m.funcUploadInfoOrigin)
	}

	if !m.UploadInfoMock.invocationsDone() && afterUploadInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to ProfileSvcMock.UploadInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadInfoMock.expectedInvocations), m.UploadInfoMock.expectedInvocationsOrigin, afterUploadInfoCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProfileSvcMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteCardInspect()

			m.MinimockGetUserCardsInspect()

			m.MinimockUploadInfoInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProfileSvcMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProfileSvcMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteCardDone() &&
		m.MinimockGetUserCardsDone() &&
		m.MinimockUploadInfoDone()
}
