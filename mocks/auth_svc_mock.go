// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mock_service

//go:generate minimock -i github.com/gleb-korostelev/GophKeeper/internal/handler.AuthSvc -o auth_svc_mock.go -n AuthSvcMock -p mock_service

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gleb-korostelev/GophKeeper/models"
	"github.com/gojuno/minimock/v3"
)

// AuthSvcMock implements mm_handler.AuthSvc
type AuthSvcMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateProfile          func(ctx context.Context, profile models.Profile) (challenge string, err error)
	funcCreateProfileOrigin    string
	inspectFuncCreateProfile   func(ctx context.Context, profile models.Profile)
	afterCreateProfileCounter  uint64
	beforeCreateProfileCounter uint64
	CreateProfileMock          mAuthSvcMockCreateProfile

	funcGetAccountByUserName          func(ctx context.Context, username string) (acc models.Account, err error)
	funcGetAccountByUserNameOrigin    string
	inspectFuncGetAccountByUserName   func(ctx context.Context, username string)
	afterGetAccountByUserNameCounter  uint64
	beforeGetAccountByUserNameCounter uint64
	GetAccountByUserNameMock          mAuthSvcMockGetAccountByUserName

	funcGetChallenge          func(ctx context.Context, profile models.Profile) (challenge string, err error)
	funcGetChallengeOrigin    string
	inspectFuncGetChallenge   func(ctx context.Context, profile models.Profile)
	afterGetChallengeCounter  uint64
	beforeGetChallengeCounter uint64
	GetChallengeMock          mAuthSvcMockGetChallenge

	funcSignIn          func(ctx context.Context, profile models.Profile, challenge string) (token string, refresh string, err error)
	funcSignInOrigin    string
	inspectFuncSignIn   func(ctx context.Context, profile models.Profile, challenge string)
	afterSignInCounter  uint64
	beforeSignInCounter uint64
	SignInMock          mAuthSvcMockSignIn
}

// NewAuthSvcMock returns a mock for mm_handler.AuthSvc
func NewAuthSvcMock(t minimock.Tester) *AuthSvcMock {
	m := &AuthSvcMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateProfileMock = mAuthSvcMockCreateProfile{mock: m}
	m.CreateProfileMock.callArgs = []*AuthSvcMockCreateProfileParams{}

	m.GetAccountByUserNameMock = mAuthSvcMockGetAccountByUserName{mock: m}
	m.GetAccountByUserNameMock.callArgs = []*AuthSvcMockGetAccountByUserNameParams{}

	m.GetChallengeMock = mAuthSvcMockGetChallenge{mock: m}
	m.GetChallengeMock.callArgs = []*AuthSvcMockGetChallengeParams{}

	m.SignInMock = mAuthSvcMockSignIn{mock: m}
	m.SignInMock.callArgs = []*AuthSvcMockSignInParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthSvcMockCreateProfile struct {
	optional           bool
	mock               *AuthSvcMock
	defaultExpectation *AuthSvcMockCreateProfileExpectation
	expectations       []*AuthSvcMockCreateProfileExpectation

	callArgs []*AuthSvcMockCreateProfileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthSvcMockCreateProfileExpectation specifies expectation struct of the AuthSvc.CreateProfile
type AuthSvcMockCreateProfileExpectation struct {
	mock               *AuthSvcMock
	params             *AuthSvcMockCreateProfileParams
	paramPtrs          *AuthSvcMockCreateProfileParamPtrs
	expectationOrigins AuthSvcMockCreateProfileExpectationOrigins
	results            *AuthSvcMockCreateProfileResults
	returnOrigin       string
	Counter            uint64
}

// AuthSvcMockCreateProfileParams contains parameters of the AuthSvc.CreateProfile
type AuthSvcMockCreateProfileParams struct {
	ctx     context.Context
	profile models.Profile
}

// AuthSvcMockCreateProfileParamPtrs contains pointers to parameters of the AuthSvc.CreateProfile
type AuthSvcMockCreateProfileParamPtrs struct {
	ctx     *context.Context
	profile *models.Profile
}

// AuthSvcMockCreateProfileResults contains results of the AuthSvc.CreateProfile
type AuthSvcMockCreateProfileResults struct {
	challenge string
	err       error
}

// AuthSvcMockCreateProfileOrigins contains origins of expectations of the AuthSvc.CreateProfile
type AuthSvcMockCreateProfileExpectationOrigins struct {
	origin        string
	originCtx     string
	originProfile string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateProfile *mAuthSvcMockCreateProfile) Optional() *mAuthSvcMockCreateProfile {
	mmCreateProfile.optional = true
	return mmCreateProfile
}

// Expect sets up expected params for AuthSvc.CreateProfile
func (mmCreateProfile *mAuthSvcMockCreateProfile) Expect(ctx context.Context, profile models.Profile) *mAuthSvcMockCreateProfile {
	if mmCreateProfile.mock.funcCreateProfile != nil {
		mmCreateProfile.mock.t.Fatalf("AuthSvcMock.CreateProfile mock is already set by Set")
	}

	if mmCreateProfile.defaultExpectation == nil {
		mmCreateProfile.defaultExpectation = &AuthSvcMockCreateProfileExpectation{}
	}

	if mmCreateProfile.defaultExpectation.paramPtrs != nil {
		mmCreateProfile.mock.t.Fatalf("AuthSvcMock.CreateProfile mock is already set by ExpectParams functions")
	}

	mmCreateProfile.defaultExpectation.params = &AuthSvcMockCreateProfileParams{ctx, profile}
	mmCreateProfile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateProfile.expectations {
		if minimock.Equal(e.params, mmCreateProfile.defaultExpectation.params) {
			mmCreateProfile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateProfile.defaultExpectation.params)
		}
	}

	return mmCreateProfile
}

// ExpectCtxParam1 sets up expected param ctx for AuthSvc.CreateProfile
func (mmCreateProfile *mAuthSvcMockCreateProfile) ExpectCtxParam1(ctx context.Context) *mAuthSvcMockCreateProfile {
	if mmCreateProfile.mock.funcCreateProfile != nil {
		mmCreateProfile.mock.t.Fatalf("AuthSvcMock.CreateProfile mock is already set by Set")
	}

	if mmCreateProfile.defaultExpectation == nil {
		mmCreateProfile.defaultExpectation = &AuthSvcMockCreateProfileExpectation{}
	}

	if mmCreateProfile.defaultExpectation.params != nil {
		mmCreateProfile.mock.t.Fatalf("AuthSvcMock.CreateProfile mock is already set by Expect")
	}

	if mmCreateProfile.defaultExpectation.paramPtrs == nil {
		mmCreateProfile.defaultExpectation.paramPtrs = &AuthSvcMockCreateProfileParamPtrs{}
	}
	mmCreateProfile.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateProfile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateProfile
}

// ExpectProfileParam2 sets up expected param profile for AuthSvc.CreateProfile
func (mmCreateProfile *mAuthSvcMockCreateProfile) ExpectProfileParam2(profile models.Profile) *mAuthSvcMockCreateProfile {
	if mmCreateProfile.mock.funcCreateProfile != nil {
		mmCreateProfile.mock.t.Fatalf("AuthSvcMock.CreateProfile mock is already set by Set")
	}

	if mmCreateProfile.defaultExpectation == nil {
		mmCreateProfile.defaultExpectation = &AuthSvcMockCreateProfileExpectation{}
	}

	if mmCreateProfile.defaultExpectation.params != nil {
		mmCreateProfile.mock.t.Fatalf("AuthSvcMock.CreateProfile mock is already set by Expect")
	}

	if mmCreateProfile.defaultExpectation.paramPtrs == nil {
		mmCreateProfile.defaultExpectation.paramPtrs = &AuthSvcMockCreateProfileParamPtrs{}
	}
	mmCreateProfile.defaultExpectation.paramPtrs.profile = &profile
	mmCreateProfile.defaultExpectation.expectationOrigins.originProfile = minimock.CallerInfo(1)

	return mmCreateProfile
}

// Inspect accepts an inspector function that has same arguments as the AuthSvc.CreateProfile
func (mmCreateProfile *mAuthSvcMockCreateProfile) Inspect(f func(ctx context.Context, profile models.Profile)) *mAuthSvcMockCreateProfile {
	if mmCreateProfile.mock.inspectFuncCreateProfile != nil {
		mmCreateProfile.mock.t.Fatalf("Inspect function is already set for AuthSvcMock.CreateProfile")
	}

	mmCreateProfile.mock.inspectFuncCreateProfile = f

	return mmCreateProfile
}

// Return sets up results that will be returned by AuthSvc.CreateProfile
func (mmCreateProfile *mAuthSvcMockCreateProfile) Return(challenge string, err error) *AuthSvcMock {
	if mmCreateProfile.mock.funcCreateProfile != nil {
		mmCreateProfile.mock.t.Fatalf("AuthSvcMock.CreateProfile mock is already set by Set")
	}

	if mmCreateProfile.defaultExpectation == nil {
		mmCreateProfile.defaultExpectation = &AuthSvcMockCreateProfileExpectation{mock: mmCreateProfile.mock}
	}
	mmCreateProfile.defaultExpectation.results = &AuthSvcMockCreateProfileResults{challenge, err}
	mmCreateProfile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateProfile.mock
}

// Set uses given function f to mock the AuthSvc.CreateProfile method
func (mmCreateProfile *mAuthSvcMockCreateProfile) Set(f func(ctx context.Context, profile models.Profile) (challenge string, err error)) *AuthSvcMock {
	if mmCreateProfile.defaultExpectation != nil {
		mmCreateProfile.mock.t.Fatalf("Default expectation is already set for the AuthSvc.CreateProfile method")
	}

	if len(mmCreateProfile.expectations) > 0 {
		mmCreateProfile.mock.t.Fatalf("Some expectations are already set for the AuthSvc.CreateProfile method")
	}

	mmCreateProfile.mock.funcCreateProfile = f
	mmCreateProfile.mock.funcCreateProfileOrigin = minimock.CallerInfo(1)
	return mmCreateProfile.mock
}

// When sets expectation for the AuthSvc.CreateProfile which will trigger the result defined by the following
// Then helper
func (mmCreateProfile *mAuthSvcMockCreateProfile) When(ctx context.Context, profile models.Profile) *AuthSvcMockCreateProfileExpectation {
	if mmCreateProfile.mock.funcCreateProfile != nil {
		mmCreateProfile.mock.t.Fatalf("AuthSvcMock.CreateProfile mock is already set by Set")
	}

	expectation := &AuthSvcMockCreateProfileExpectation{
		mock:               mmCreateProfile.mock,
		params:             &AuthSvcMockCreateProfileParams{ctx, profile},
		expectationOrigins: AuthSvcMockCreateProfileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateProfile.expectations = append(mmCreateProfile.expectations, expectation)
	return expectation
}

// Then sets up AuthSvc.CreateProfile return parameters for the expectation previously defined by the When method
func (e *AuthSvcMockCreateProfileExpectation) Then(challenge string, err error) *AuthSvcMock {
	e.results = &AuthSvcMockCreateProfileResults{challenge, err}
	return e.mock
}

// Times sets number of times AuthSvc.CreateProfile should be invoked
func (mmCreateProfile *mAuthSvcMockCreateProfile) Times(n uint64) *mAuthSvcMockCreateProfile {
	if n == 0 {
		mmCreateProfile.mock.t.Fatalf("Times of AuthSvcMock.CreateProfile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateProfile.expectedInvocations, n)
	mmCreateProfile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateProfile
}

func (mmCreateProfile *mAuthSvcMockCreateProfile) invocationsDone() bool {
	if len(mmCreateProfile.expectations) == 0 && mmCreateProfile.defaultExpectation == nil && mmCreateProfile.mock.funcCreateProfile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateProfile.mock.afterCreateProfileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateProfile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateProfile implements mm_handler.AuthSvc
func (mmCreateProfile *AuthSvcMock) CreateProfile(ctx context.Context, profile models.Profile) (challenge string, err error) {
	mm_atomic.AddUint64(&mmCreateProfile.beforeCreateProfileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateProfile.afterCreateProfileCounter, 1)

	mmCreateProfile.t.Helper()

	if mmCreateProfile.inspectFuncCreateProfile != nil {
		mmCreateProfile.inspectFuncCreateProfile(ctx, profile)
	}

	mm_params := AuthSvcMockCreateProfileParams{ctx, profile}

	// Record call args
	mmCreateProfile.CreateProfileMock.mutex.Lock()
	mmCreateProfile.CreateProfileMock.callArgs = append(mmCreateProfile.CreateProfileMock.callArgs, &mm_params)
	mmCreateProfile.CreateProfileMock.mutex.Unlock()

	for _, e := range mmCreateProfile.CreateProfileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.challenge, e.results.err
		}
	}

	if mmCreateProfile.CreateProfileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateProfile.CreateProfileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateProfile.CreateProfileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateProfile.CreateProfileMock.defaultExpectation.paramPtrs

		mm_got := AuthSvcMockCreateProfileParams{ctx, profile}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateProfile.t.Errorf("AuthSvcMock.CreateProfile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProfile.CreateProfileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.profile != nil && !minimock.Equal(*mm_want_ptrs.profile, mm_got.profile) {
				mmCreateProfile.t.Errorf("AuthSvcMock.CreateProfile got unexpected parameter profile, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProfile.CreateProfileMock.defaultExpectation.expectationOrigins.originProfile, *mm_want_ptrs.profile, mm_got.profile, minimock.Diff(*mm_want_ptrs.profile, mm_got.profile))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateProfile.t.Errorf("AuthSvcMock.CreateProfile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateProfile.CreateProfileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateProfile.CreateProfileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateProfile.t.Fatal("No results are set for the AuthSvcMock.CreateProfile")
		}
		return (*mm_results).challenge, (*mm_results).err
	}
	if mmCreateProfile.funcCreateProfile != nil {
		return mmCreateProfile.funcCreateProfile(ctx, profile)
	}
	mmCreateProfile.t.Fatalf("Unexpected call to AuthSvcMock.CreateProfile. %v %v", ctx, profile)
	return
}

// CreateProfileAfterCounter returns a count of finished AuthSvcMock.CreateProfile invocations
func (mmCreateProfile *AuthSvcMock) CreateProfileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProfile.afterCreateProfileCounter)
}

// CreateProfileBeforeCounter returns a count of AuthSvcMock.CreateProfile invocations
func (mmCreateProfile *AuthSvcMock) CreateProfileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProfile.beforeCreateProfileCounter)
}

// Calls returns a list of arguments used in each call to AuthSvcMock.CreateProfile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateProfile *mAuthSvcMockCreateProfile) Calls() []*AuthSvcMockCreateProfileParams {
	mmCreateProfile.mutex.RLock()

	argCopy := make([]*AuthSvcMockCreateProfileParams, len(mmCreateProfile.callArgs))
	copy(argCopy, mmCreateProfile.callArgs)

	mmCreateProfile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateProfileDone returns true if the count of the CreateProfile invocations corresponds
// the number of defined expectations
func (m *AuthSvcMock) MinimockCreateProfileDone() bool {
	if m.CreateProfileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateProfileMock.invocationsDone()
}

// MinimockCreateProfileInspect logs each unmet expectation
func (m *AuthSvcMock) MinimockCreateProfileInspect() {
	for _, e := range m.CreateProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthSvcMock.CreateProfile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateProfileCounter := mm_atomic.LoadUint64(&m.afterCreateProfileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateProfileMock.defaultExpectation != nil && afterCreateProfileCounter < 1 {
		if m.CreateProfileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthSvcMock.CreateProfile at\n%s", m.CreateProfileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthSvcMock.CreateProfile at\n%s with params: %#v", m.CreateProfileMock.defaultExpectation.expectationOrigins.origin, *m.CreateProfileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateProfile != nil && afterCreateProfileCounter < 1 {
		m.t.Errorf("Expected call to AuthSvcMock.CreateProfile at\n%s", m.funcCreateProfileOrigin)
	}

	if !m.CreateProfileMock.invocationsDone() && afterCreateProfileCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthSvcMock.CreateProfile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateProfileMock.expectedInvocations), m.CreateProfileMock.expectedInvocationsOrigin, afterCreateProfileCounter)
	}
}

type mAuthSvcMockGetAccountByUserName struct {
	optional           bool
	mock               *AuthSvcMock
	defaultExpectation *AuthSvcMockGetAccountByUserNameExpectation
	expectations       []*AuthSvcMockGetAccountByUserNameExpectation

	callArgs []*AuthSvcMockGetAccountByUserNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthSvcMockGetAccountByUserNameExpectation specifies expectation struct of the AuthSvc.GetAccountByUserName
type AuthSvcMockGetAccountByUserNameExpectation struct {
	mock               *AuthSvcMock
	params             *AuthSvcMockGetAccountByUserNameParams
	paramPtrs          *AuthSvcMockGetAccountByUserNameParamPtrs
	expectationOrigins AuthSvcMockGetAccountByUserNameExpectationOrigins
	results            *AuthSvcMockGetAccountByUserNameResults
	returnOrigin       string
	Counter            uint64
}

// AuthSvcMockGetAccountByUserNameParams contains parameters of the AuthSvc.GetAccountByUserName
type AuthSvcMockGetAccountByUserNameParams struct {
	ctx      context.Context
	username string
}

// AuthSvcMockGetAccountByUserNameParamPtrs contains pointers to parameters of the AuthSvc.GetAccountByUserName
type AuthSvcMockGetAccountByUserNameParamPtrs struct {
	ctx      *context.Context
	username *string
}

// AuthSvcMockGetAccountByUserNameResults contains results of the AuthSvc.GetAccountByUserName
type AuthSvcMockGetAccountByUserNameResults struct {
	acc models.Account
	err error
}

// AuthSvcMockGetAccountByUserNameOrigins contains origins of expectations of the AuthSvc.GetAccountByUserName
type AuthSvcMockGetAccountByUserNameExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAccountByUserName *mAuthSvcMockGetAccountByUserName) Optional() *mAuthSvcMockGetAccountByUserName {
	mmGetAccountByUserName.optional = true
	return mmGetAccountByUserName
}

// Expect sets up expected params for AuthSvc.GetAccountByUserName
func (mmGetAccountByUserName *mAuthSvcMockGetAccountByUserName) Expect(ctx context.Context, username string) *mAuthSvcMockGetAccountByUserName {
	if mmGetAccountByUserName.mock.funcGetAccountByUserName != nil {
		mmGetAccountByUserName.mock.t.Fatalf("AuthSvcMock.GetAccountByUserName mock is already set by Set")
	}

	if mmGetAccountByUserName.defaultExpectation == nil {
		mmGetAccountByUserName.defaultExpectation = &AuthSvcMockGetAccountByUserNameExpectation{}
	}

	if mmGetAccountByUserName.defaultExpectation.paramPtrs != nil {
		mmGetAccountByUserName.mock.t.Fatalf("AuthSvcMock.GetAccountByUserName mock is already set by ExpectParams functions")
	}

	mmGetAccountByUserName.defaultExpectation.params = &AuthSvcMockGetAccountByUserNameParams{ctx, username}
	mmGetAccountByUserName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAccountByUserName.expectations {
		if minimock.Equal(e.params, mmGetAccountByUserName.defaultExpectation.params) {
			mmGetAccountByUserName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccountByUserName.defaultExpectation.params)
		}
	}

	return mmGetAccountByUserName
}

// ExpectCtxParam1 sets up expected param ctx for AuthSvc.GetAccountByUserName
func (mmGetAccountByUserName *mAuthSvcMockGetAccountByUserName) ExpectCtxParam1(ctx context.Context) *mAuthSvcMockGetAccountByUserName {
	if mmGetAccountByUserName.mock.funcGetAccountByUserName != nil {
		mmGetAccountByUserName.mock.t.Fatalf("AuthSvcMock.GetAccountByUserName mock is already set by Set")
	}

	if mmGetAccountByUserName.defaultExpectation == nil {
		mmGetAccountByUserName.defaultExpectation = &AuthSvcMockGetAccountByUserNameExpectation{}
	}

	if mmGetAccountByUserName.defaultExpectation.params != nil {
		mmGetAccountByUserName.mock.t.Fatalf("AuthSvcMock.GetAccountByUserName mock is already set by Expect")
	}

	if mmGetAccountByUserName.defaultExpectation.paramPtrs == nil {
		mmGetAccountByUserName.defaultExpectation.paramPtrs = &AuthSvcMockGetAccountByUserNameParamPtrs{}
	}
	mmGetAccountByUserName.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAccountByUserName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAccountByUserName
}

// ExpectUsernameParam2 sets up expected param username for AuthSvc.GetAccountByUserName
func (mmGetAccountByUserName *mAuthSvcMockGetAccountByUserName) ExpectUsernameParam2(username string) *mAuthSvcMockGetAccountByUserName {
	if mmGetAccountByUserName.mock.funcGetAccountByUserName != nil {
		mmGetAccountByUserName.mock.t.Fatalf("AuthSvcMock.GetAccountByUserName mock is already set by Set")
	}

	if mmGetAccountByUserName.defaultExpectation == nil {
		mmGetAccountByUserName.defaultExpectation = &AuthSvcMockGetAccountByUserNameExpectation{}
	}

	if mmGetAccountByUserName.defaultExpectation.params != nil {
		mmGetAccountByUserName.mock.t.Fatalf("AuthSvcMock.GetAccountByUserName mock is already set by Expect")
	}

	if mmGetAccountByUserName.defaultExpectation.paramPtrs == nil {
		mmGetAccountByUserName.defaultExpectation.paramPtrs = &AuthSvcMockGetAccountByUserNameParamPtrs{}
	}
	mmGetAccountByUserName.defaultExpectation.paramPtrs.username = &username
	mmGetAccountByUserName.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetAccountByUserName
}

// Inspect accepts an inspector function that has same arguments as the AuthSvc.GetAccountByUserName
func (mmGetAccountByUserName *mAuthSvcMockGetAccountByUserName) Inspect(f func(ctx context.Context, username string)) *mAuthSvcMockGetAccountByUserName {
	if mmGetAccountByUserName.mock.inspectFuncGetAccountByUserName != nil {
		mmGetAccountByUserName.mock.t.Fatalf("Inspect function is already set for AuthSvcMock.GetAccountByUserName")
	}

	mmGetAccountByUserName.mock.inspectFuncGetAccountByUserName = f

	return mmGetAccountByUserName
}

// Return sets up results that will be returned by AuthSvc.GetAccountByUserName
func (mmGetAccountByUserName *mAuthSvcMockGetAccountByUserName) Return(acc models.Account, err error) *AuthSvcMock {
	if mmGetAccountByUserName.mock.funcGetAccountByUserName != nil {
		mmGetAccountByUserName.mock.t.Fatalf("AuthSvcMock.GetAccountByUserName mock is already set by Set")
	}

	if mmGetAccountByUserName.defaultExpectation == nil {
		mmGetAccountByUserName.defaultExpectation = &AuthSvcMockGetAccountByUserNameExpectation{mock: mmGetAccountByUserName.mock}
	}
	mmGetAccountByUserName.defaultExpectation.results = &AuthSvcMockGetAccountByUserNameResults{acc, err}
	mmGetAccountByUserName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAccountByUserName.mock
}

// Set uses given function f to mock the AuthSvc.GetAccountByUserName method
func (mmGetAccountByUserName *mAuthSvcMockGetAccountByUserName) Set(f func(ctx context.Context, username string) (acc models.Account, err error)) *AuthSvcMock {
	if mmGetAccountByUserName.defaultExpectation != nil {
		mmGetAccountByUserName.mock.t.Fatalf("Default expectation is already set for the AuthSvc.GetAccountByUserName method")
	}

	if len(mmGetAccountByUserName.expectations) > 0 {
		mmGetAccountByUserName.mock.t.Fatalf("Some expectations are already set for the AuthSvc.GetAccountByUserName method")
	}

	mmGetAccountByUserName.mock.funcGetAccountByUserName = f
	mmGetAccountByUserName.mock.funcGetAccountByUserNameOrigin = minimock.CallerInfo(1)
	return mmGetAccountByUserName.mock
}

// When sets expectation for the AuthSvc.GetAccountByUserName which will trigger the result defined by the following
// Then helper
func (mmGetAccountByUserName *mAuthSvcMockGetAccountByUserName) When(ctx context.Context, username string) *AuthSvcMockGetAccountByUserNameExpectation {
	if mmGetAccountByUserName.mock.funcGetAccountByUserName != nil {
		mmGetAccountByUserName.mock.t.Fatalf("AuthSvcMock.GetAccountByUserName mock is already set by Set")
	}

	expectation := &AuthSvcMockGetAccountByUserNameExpectation{
		mock:               mmGetAccountByUserName.mock,
		params:             &AuthSvcMockGetAccountByUserNameParams{ctx, username},
		expectationOrigins: AuthSvcMockGetAccountByUserNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAccountByUserName.expectations = append(mmGetAccountByUserName.expectations, expectation)
	return expectation
}

// Then sets up AuthSvc.GetAccountByUserName return parameters for the expectation previously defined by the When method
func (e *AuthSvcMockGetAccountByUserNameExpectation) Then(acc models.Account, err error) *AuthSvcMock {
	e.results = &AuthSvcMockGetAccountByUserNameResults{acc, err}
	return e.mock
}

// Times sets number of times AuthSvc.GetAccountByUserName should be invoked
func (mmGetAccountByUserName *mAuthSvcMockGetAccountByUserName) Times(n uint64) *mAuthSvcMockGetAccountByUserName {
	if n == 0 {
		mmGetAccountByUserName.mock.t.Fatalf("Times of AuthSvcMock.GetAccountByUserName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAccountByUserName.expectedInvocations, n)
	mmGetAccountByUserName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAccountByUserName
}

func (mmGetAccountByUserName *mAuthSvcMockGetAccountByUserName) invocationsDone() bool {
	if len(mmGetAccountByUserName.expectations) == 0 && mmGetAccountByUserName.defaultExpectation == nil && mmGetAccountByUserName.mock.funcGetAccountByUserName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAccountByUserName.mock.afterGetAccountByUserNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAccountByUserName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAccountByUserName implements mm_handler.AuthSvc
func (mmGetAccountByUserName *AuthSvcMock) GetAccountByUserName(ctx context.Context, username string) (acc models.Account, err error) {
	mm_atomic.AddUint64(&mmGetAccountByUserName.beforeGetAccountByUserNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccountByUserName.afterGetAccountByUserNameCounter, 1)

	mmGetAccountByUserName.t.Helper()

	if mmGetAccountByUserName.inspectFuncGetAccountByUserName != nil {
		mmGetAccountByUserName.inspectFuncGetAccountByUserName(ctx, username)
	}

	mm_params := AuthSvcMockGetAccountByUserNameParams{ctx, username}

	// Record call args
	mmGetAccountByUserName.GetAccountByUserNameMock.mutex.Lock()
	mmGetAccountByUserName.GetAccountByUserNameMock.callArgs = append(mmGetAccountByUserName.GetAccountByUserNameMock.callArgs, &mm_params)
	mmGetAccountByUserName.GetAccountByUserNameMock.mutex.Unlock()

	for _, e := range mmGetAccountByUserName.GetAccountByUserNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.acc, e.results.err
		}
	}

	if mmGetAccountByUserName.GetAccountByUserNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccountByUserName.GetAccountByUserNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccountByUserName.GetAccountByUserNameMock.defaultExpectation.params
		mm_want_ptrs := mmGetAccountByUserName.GetAccountByUserNameMock.defaultExpectation.paramPtrs

		mm_got := AuthSvcMockGetAccountByUserNameParams{ctx, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAccountByUserName.t.Errorf("AuthSvcMock.GetAccountByUserName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccountByUserName.GetAccountByUserNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetAccountByUserName.t.Errorf("AuthSvcMock.GetAccountByUserName got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccountByUserName.GetAccountByUserNameMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccountByUserName.t.Errorf("AuthSvcMock.GetAccountByUserName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAccountByUserName.GetAccountByUserNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccountByUserName.GetAccountByUserNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccountByUserName.t.Fatal("No results are set for the AuthSvcMock.GetAccountByUserName")
		}
		return (*mm_results).acc, (*mm_results).err
	}
	if mmGetAccountByUserName.funcGetAccountByUserName != nil {
		return mmGetAccountByUserName.funcGetAccountByUserName(ctx, username)
	}
	mmGetAccountByUserName.t.Fatalf("Unexpected call to AuthSvcMock.GetAccountByUserName. %v %v", ctx, username)
	return
}

// GetAccountByUserNameAfterCounter returns a count of finished AuthSvcMock.GetAccountByUserName invocations
func (mmGetAccountByUserName *AuthSvcMock) GetAccountByUserNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccountByUserName.afterGetAccountByUserNameCounter)
}

// GetAccountByUserNameBeforeCounter returns a count of AuthSvcMock.GetAccountByUserName invocations
func (mmGetAccountByUserName *AuthSvcMock) GetAccountByUserNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccountByUserName.beforeGetAccountByUserNameCounter)
}

// Calls returns a list of arguments used in each call to AuthSvcMock.GetAccountByUserName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccountByUserName *mAuthSvcMockGetAccountByUserName) Calls() []*AuthSvcMockGetAccountByUserNameParams {
	mmGetAccountByUserName.mutex.RLock()

	argCopy := make([]*AuthSvcMockGetAccountByUserNameParams, len(mmGetAccountByUserName.callArgs))
	copy(argCopy, mmGetAccountByUserName.callArgs)

	mmGetAccountByUserName.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccountByUserNameDone returns true if the count of the GetAccountByUserName invocations corresponds
// the number of defined expectations
func (m *AuthSvcMock) MinimockGetAccountByUserNameDone() bool {
	if m.GetAccountByUserNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAccountByUserNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAccountByUserNameMock.invocationsDone()
}

// MinimockGetAccountByUserNameInspect logs each unmet expectation
func (m *AuthSvcMock) MinimockGetAccountByUserNameInspect() {
	for _, e := range m.GetAccountByUserNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthSvcMock.GetAccountByUserName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAccountByUserNameCounter := mm_atomic.LoadUint64(&m.afterGetAccountByUserNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccountByUserNameMock.defaultExpectation != nil && afterGetAccountByUserNameCounter < 1 {
		if m.GetAccountByUserNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthSvcMock.GetAccountByUserName at\n%s", m.GetAccountByUserNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthSvcMock.GetAccountByUserName at\n%s with params: %#v", m.GetAccountByUserNameMock.defaultExpectation.expectationOrigins.origin, *m.GetAccountByUserNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccountByUserName != nil && afterGetAccountByUserNameCounter < 1 {
		m.t.Errorf("Expected call to AuthSvcMock.GetAccountByUserName at\n%s", m.funcGetAccountByUserNameOrigin)
	}

	if !m.GetAccountByUserNameMock.invocationsDone() && afterGetAccountByUserNameCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthSvcMock.GetAccountByUserName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAccountByUserNameMock.expectedInvocations), m.GetAccountByUserNameMock.expectedInvocationsOrigin, afterGetAccountByUserNameCounter)
	}
}

type mAuthSvcMockGetChallenge struct {
	optional           bool
	mock               *AuthSvcMock
	defaultExpectation *AuthSvcMockGetChallengeExpectation
	expectations       []*AuthSvcMockGetChallengeExpectation

	callArgs []*AuthSvcMockGetChallengeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthSvcMockGetChallengeExpectation specifies expectation struct of the AuthSvc.GetChallenge
type AuthSvcMockGetChallengeExpectation struct {
	mock               *AuthSvcMock
	params             *AuthSvcMockGetChallengeParams
	paramPtrs          *AuthSvcMockGetChallengeParamPtrs
	expectationOrigins AuthSvcMockGetChallengeExpectationOrigins
	results            *AuthSvcMockGetChallengeResults
	returnOrigin       string
	Counter            uint64
}

// AuthSvcMockGetChallengeParams contains parameters of the AuthSvc.GetChallenge
type AuthSvcMockGetChallengeParams struct {
	ctx     context.Context
	profile models.Profile
}

// AuthSvcMockGetChallengeParamPtrs contains pointers to parameters of the AuthSvc.GetChallenge
type AuthSvcMockGetChallengeParamPtrs struct {
	ctx     *context.Context
	profile *models.Profile
}

// AuthSvcMockGetChallengeResults contains results of the AuthSvc.GetChallenge
type AuthSvcMockGetChallengeResults struct {
	challenge string
	err       error
}

// AuthSvcMockGetChallengeOrigins contains origins of expectations of the AuthSvc.GetChallenge
type AuthSvcMockGetChallengeExpectationOrigins struct {
	origin        string
	originCtx     string
	originProfile string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChallenge *mAuthSvcMockGetChallenge) Optional() *mAuthSvcMockGetChallenge {
	mmGetChallenge.optional = true
	return mmGetChallenge
}

// Expect sets up expected params for AuthSvc.GetChallenge
func (mmGetChallenge *mAuthSvcMockGetChallenge) Expect(ctx context.Context, profile models.Profile) *mAuthSvcMockGetChallenge {
	if mmGetChallenge.mock.funcGetChallenge != nil {
		mmGetChallenge.mock.t.Fatalf("AuthSvcMock.GetChallenge mock is already set by Set")
	}

	if mmGetChallenge.defaultExpectation == nil {
		mmGetChallenge.defaultExpectation = &AuthSvcMockGetChallengeExpectation{}
	}

	if mmGetChallenge.defaultExpectation.paramPtrs != nil {
		mmGetChallenge.mock.t.Fatalf("AuthSvcMock.GetChallenge mock is already set by ExpectParams functions")
	}

	mmGetChallenge.defaultExpectation.params = &AuthSvcMockGetChallengeParams{ctx, profile}
	mmGetChallenge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChallenge.expectations {
		if minimock.Equal(e.params, mmGetChallenge.defaultExpectation.params) {
			mmGetChallenge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChallenge.defaultExpectation.params)
		}
	}

	return mmGetChallenge
}

// ExpectCtxParam1 sets up expected param ctx for AuthSvc.GetChallenge
func (mmGetChallenge *mAuthSvcMockGetChallenge) ExpectCtxParam1(ctx context.Context) *mAuthSvcMockGetChallenge {
	if mmGetChallenge.mock.funcGetChallenge != nil {
		mmGetChallenge.mock.t.Fatalf("AuthSvcMock.GetChallenge mock is already set by Set")
	}

	if mmGetChallenge.defaultExpectation == nil {
		mmGetChallenge.defaultExpectation = &AuthSvcMockGetChallengeExpectation{}
	}

	if mmGetChallenge.defaultExpectation.params != nil {
		mmGetChallenge.mock.t.Fatalf("AuthSvcMock.GetChallenge mock is already set by Expect")
	}

	if mmGetChallenge.defaultExpectation.paramPtrs == nil {
		mmGetChallenge.defaultExpectation.paramPtrs = &AuthSvcMockGetChallengeParamPtrs{}
	}
	mmGetChallenge.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChallenge.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChallenge
}

// ExpectProfileParam2 sets up expected param profile for AuthSvc.GetChallenge
func (mmGetChallenge *mAuthSvcMockGetChallenge) ExpectProfileParam2(profile models.Profile) *mAuthSvcMockGetChallenge {
	if mmGetChallenge.mock.funcGetChallenge != nil {
		mmGetChallenge.mock.t.Fatalf("AuthSvcMock.GetChallenge mock is already set by Set")
	}

	if mmGetChallenge.defaultExpectation == nil {
		mmGetChallenge.defaultExpectation = &AuthSvcMockGetChallengeExpectation{}
	}

	if mmGetChallenge.defaultExpectation.params != nil {
		mmGetChallenge.mock.t.Fatalf("AuthSvcMock.GetChallenge mock is already set by Expect")
	}

	if mmGetChallenge.defaultExpectation.paramPtrs == nil {
		mmGetChallenge.defaultExpectation.paramPtrs = &AuthSvcMockGetChallengeParamPtrs{}
	}
	mmGetChallenge.defaultExpectation.paramPtrs.profile = &profile
	mmGetChallenge.defaultExpectation.expectationOrigins.originProfile = minimock.CallerInfo(1)

	return mmGetChallenge
}

// Inspect accepts an inspector function that has same arguments as the AuthSvc.GetChallenge
func (mmGetChallenge *mAuthSvcMockGetChallenge) Inspect(f func(ctx context.Context, profile models.Profile)) *mAuthSvcMockGetChallenge {
	if mmGetChallenge.mock.inspectFuncGetChallenge != nil {
		mmGetChallenge.mock.t.Fatalf("Inspect function is already set for AuthSvcMock.GetChallenge")
	}

	mmGetChallenge.mock.inspectFuncGetChallenge = f

	return mmGetChallenge
}

// Return sets up results that will be returned by AuthSvc.GetChallenge
func (mmGetChallenge *mAuthSvcMockGetChallenge) Return(challenge string, err error) *AuthSvcMock {
	if mmGetChallenge.mock.funcGetChallenge != nil {
		mmGetChallenge.mock.t.Fatalf("AuthSvcMock.GetChallenge mock is already set by Set")
	}

	if mmGetChallenge.defaultExpectation == nil {
		mmGetChallenge.defaultExpectation = &AuthSvcMockGetChallengeExpectation{mock: mmGetChallenge.mock}
	}
	mmGetChallenge.defaultExpectation.results = &AuthSvcMockGetChallengeResults{challenge, err}
	mmGetChallenge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChallenge.mock
}

// Set uses given function f to mock the AuthSvc.GetChallenge method
func (mmGetChallenge *mAuthSvcMockGetChallenge) Set(f func(ctx context.Context, profile models.Profile) (challenge string, err error)) *AuthSvcMock {
	if mmGetChallenge.defaultExpectation != nil {
		mmGetChallenge.mock.t.Fatalf("Default expectation is already set for the AuthSvc.GetChallenge method")
	}

	if len(mmGetChallenge.expectations) > 0 {
		mmGetChallenge.mock.t.Fatalf("Some expectations are already set for the AuthSvc.GetChallenge method")
	}

	mmGetChallenge.mock.funcGetChallenge = f
	mmGetChallenge.mock.funcGetChallengeOrigin = minimock.CallerInfo(1)
	return mmGetChallenge.mock
}

// When sets expectation for the AuthSvc.GetChallenge which will trigger the result defined by the following
// Then helper
func (mmGetChallenge *mAuthSvcMockGetChallenge) When(ctx context.Context, profile models.Profile) *AuthSvcMockGetChallengeExpectation {
	if mmGetChallenge.mock.funcGetChallenge != nil {
		mmGetChallenge.mock.t.Fatalf("AuthSvcMock.GetChallenge mock is already set by Set")
	}

	expectation := &AuthSvcMockGetChallengeExpectation{
		mock:               mmGetChallenge.mock,
		params:             &AuthSvcMockGetChallengeParams{ctx, profile},
		expectationOrigins: AuthSvcMockGetChallengeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChallenge.expectations = append(mmGetChallenge.expectations, expectation)
	return expectation
}

// Then sets up AuthSvc.GetChallenge return parameters for the expectation previously defined by the When method
func (e *AuthSvcMockGetChallengeExpectation) Then(challenge string, err error) *AuthSvcMock {
	e.results = &AuthSvcMockGetChallengeResults{challenge, err}
	return e.mock
}

// Times sets number of times AuthSvc.GetChallenge should be invoked
func (mmGetChallenge *mAuthSvcMockGetChallenge) Times(n uint64) *mAuthSvcMockGetChallenge {
	if n == 0 {
		mmGetChallenge.mock.t.Fatalf("Times of AuthSvcMock.GetChallenge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChallenge.expectedInvocations, n)
	mmGetChallenge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChallenge
}

func (mmGetChallenge *mAuthSvcMockGetChallenge) invocationsDone() bool {
	if len(mmGetChallenge.expectations) == 0 && mmGetChallenge.defaultExpectation == nil && mmGetChallenge.mock.funcGetChallenge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChallenge.mock.afterGetChallengeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChallenge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChallenge implements mm_handler.AuthSvc
func (mmGetChallenge *AuthSvcMock) GetChallenge(ctx context.Context, profile models.Profile) (challenge string, err error) {
	mm_atomic.AddUint64(&mmGetChallenge.beforeGetChallengeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChallenge.afterGetChallengeCounter, 1)

	mmGetChallenge.t.Helper()

	if mmGetChallenge.inspectFuncGetChallenge != nil {
		mmGetChallenge.inspectFuncGetChallenge(ctx, profile)
	}

	mm_params := AuthSvcMockGetChallengeParams{ctx, profile}

	// Record call args
	mmGetChallenge.GetChallengeMock.mutex.Lock()
	mmGetChallenge.GetChallengeMock.callArgs = append(mmGetChallenge.GetChallengeMock.callArgs, &mm_params)
	mmGetChallenge.GetChallengeMock.mutex.Unlock()

	for _, e := range mmGetChallenge.GetChallengeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.challenge, e.results.err
		}
	}

	if mmGetChallenge.GetChallengeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChallenge.GetChallengeMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChallenge.GetChallengeMock.defaultExpectation.params
		mm_want_ptrs := mmGetChallenge.GetChallengeMock.defaultExpectation.paramPtrs

		mm_got := AuthSvcMockGetChallengeParams{ctx, profile}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChallenge.t.Errorf("AuthSvcMock.GetChallenge got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChallenge.GetChallengeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.profile != nil && !minimock.Equal(*mm_want_ptrs.profile, mm_got.profile) {
				mmGetChallenge.t.Errorf("AuthSvcMock.GetChallenge got unexpected parameter profile, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChallenge.GetChallengeMock.defaultExpectation.expectationOrigins.originProfile, *mm_want_ptrs.profile, mm_got.profile, minimock.Diff(*mm_want_ptrs.profile, mm_got.profile))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChallenge.t.Errorf("AuthSvcMock.GetChallenge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChallenge.GetChallengeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChallenge.GetChallengeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChallenge.t.Fatal("No results are set for the AuthSvcMock.GetChallenge")
		}
		return (*mm_results).challenge, (*mm_results).err
	}
	if mmGetChallenge.funcGetChallenge != nil {
		return mmGetChallenge.funcGetChallenge(ctx, profile)
	}
	mmGetChallenge.t.Fatalf("Unexpected call to AuthSvcMock.GetChallenge. %v %v", ctx, profile)
	return
}

// GetChallengeAfterCounter returns a count of finished AuthSvcMock.GetChallenge invocations
func (mmGetChallenge *AuthSvcMock) GetChallengeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChallenge.afterGetChallengeCounter)
}

// GetChallengeBeforeCounter returns a count of AuthSvcMock.GetChallenge invocations
func (mmGetChallenge *AuthSvcMock) GetChallengeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChallenge.beforeGetChallengeCounter)
}

// Calls returns a list of arguments used in each call to AuthSvcMock.GetChallenge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChallenge *mAuthSvcMockGetChallenge) Calls() []*AuthSvcMockGetChallengeParams {
	mmGetChallenge.mutex.RLock()

	argCopy := make([]*AuthSvcMockGetChallengeParams, len(mmGetChallenge.callArgs))
	copy(argCopy, mmGetChallenge.callArgs)

	mmGetChallenge.mutex.RUnlock()

	return argCopy
}

// MinimockGetChallengeDone returns true if the count of the GetChallenge invocations corresponds
// the number of defined expectations
func (m *AuthSvcMock) MinimockGetChallengeDone() bool {
	if m.GetChallengeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChallengeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChallengeMock.invocationsDone()
}

// MinimockGetChallengeInspect logs each unmet expectation
func (m *AuthSvcMock) MinimockGetChallengeInspect() {
	for _, e := range m.GetChallengeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthSvcMock.GetChallenge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChallengeCounter := mm_atomic.LoadUint64(&m.afterGetChallengeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChallengeMock.defaultExpectation != nil && afterGetChallengeCounter < 1 {
		if m.GetChallengeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthSvcMock.GetChallenge at\n%s", m.GetChallengeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthSvcMock.GetChallenge at\n%s with params: %#v", m.GetChallengeMock.defaultExpectation.expectationOrigins.origin, *m.GetChallengeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChallenge != nil && afterGetChallengeCounter < 1 {
		m.t.Errorf("Expected call to AuthSvcMock.GetChallenge at\n%s", m.funcGetChallengeOrigin)
	}

	if !m.GetChallengeMock.invocationsDone() && afterGetChallengeCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthSvcMock.GetChallenge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChallengeMock.expectedInvocations), m.GetChallengeMock.expectedInvocationsOrigin, afterGetChallengeCounter)
	}
}

type mAuthSvcMockSignIn struct {
	optional           bool
	mock               *AuthSvcMock
	defaultExpectation *AuthSvcMockSignInExpectation
	expectations       []*AuthSvcMockSignInExpectation

	callArgs []*AuthSvcMockSignInParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthSvcMockSignInExpectation specifies expectation struct of the AuthSvc.SignIn
type AuthSvcMockSignInExpectation struct {
	mock               *AuthSvcMock
	params             *AuthSvcMockSignInParams
	paramPtrs          *AuthSvcMockSignInParamPtrs
	expectationOrigins AuthSvcMockSignInExpectationOrigins
	results            *AuthSvcMockSignInResults
	returnOrigin       string
	Counter            uint64
}

// AuthSvcMockSignInParams contains parameters of the AuthSvc.SignIn
type AuthSvcMockSignInParams struct {
	ctx       context.Context
	profile   models.Profile
	challenge string
}

// AuthSvcMockSignInParamPtrs contains pointers to parameters of the AuthSvc.SignIn
type AuthSvcMockSignInParamPtrs struct {
	ctx       *context.Context
	profile   *models.Profile
	challenge *string
}

// AuthSvcMockSignInResults contains results of the AuthSvc.SignIn
type AuthSvcMockSignInResults struct {
	token   string
	refresh string
	err     error
}

// AuthSvcMockSignInOrigins contains origins of expectations of the AuthSvc.SignIn
type AuthSvcMockSignInExpectationOrigins struct {
	origin          string
	originCtx       string
	originProfile   string
	originChallenge string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSignIn *mAuthSvcMockSignIn) Optional() *mAuthSvcMockSignIn {
	mmSignIn.optional = true
	return mmSignIn
}

// Expect sets up expected params for AuthSvc.SignIn
func (mmSignIn *mAuthSvcMockSignIn) Expect(ctx context.Context, profile models.Profile, challenge string) *mAuthSvcMockSignIn {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthSvcMock.SignIn mock is already set by Set")
	}

	if mmSignIn.defaultExpectation == nil {
		mmSignIn.defaultExpectation = &AuthSvcMockSignInExpectation{}
	}

	if mmSignIn.defaultExpectation.paramPtrs != nil {
		mmSignIn.mock.t.Fatalf("AuthSvcMock.SignIn mock is already set by ExpectParams functions")
	}

	mmSignIn.defaultExpectation.params = &AuthSvcMockSignInParams{ctx, profile, challenge}
	mmSignIn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSignIn.expectations {
		if minimock.Equal(e.params, mmSignIn.defaultExpectation.params) {
			mmSignIn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignIn.defaultExpectation.params)
		}
	}

	return mmSignIn
}

// ExpectCtxParam1 sets up expected param ctx for AuthSvc.SignIn
func (mmSignIn *mAuthSvcMockSignIn) ExpectCtxParam1(ctx context.Context) *mAuthSvcMockSignIn {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthSvcMock.SignIn mock is already set by Set")
	}

	if mmSignIn.defaultExpectation == nil {
		mmSignIn.defaultExpectation = &AuthSvcMockSignInExpectation{}
	}

	if mmSignIn.defaultExpectation.params != nil {
		mmSignIn.mock.t.Fatalf("AuthSvcMock.SignIn mock is already set by Expect")
	}

	if mmSignIn.defaultExpectation.paramPtrs == nil {
		mmSignIn.defaultExpectation.paramPtrs = &AuthSvcMockSignInParamPtrs{}
	}
	mmSignIn.defaultExpectation.paramPtrs.ctx = &ctx
	mmSignIn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSignIn
}

// ExpectProfileParam2 sets up expected param profile for AuthSvc.SignIn
func (mmSignIn *mAuthSvcMockSignIn) ExpectProfileParam2(profile models.Profile) *mAuthSvcMockSignIn {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthSvcMock.SignIn mock is already set by Set")
	}

	if mmSignIn.defaultExpectation == nil {
		mmSignIn.defaultExpectation = &AuthSvcMockSignInExpectation{}
	}

	if mmSignIn.defaultExpectation.params != nil {
		mmSignIn.mock.t.Fatalf("AuthSvcMock.SignIn mock is already set by Expect")
	}

	if mmSignIn.defaultExpectation.paramPtrs == nil {
		mmSignIn.defaultExpectation.paramPtrs = &AuthSvcMockSignInParamPtrs{}
	}
	mmSignIn.defaultExpectation.paramPtrs.profile = &profile
	mmSignIn.defaultExpectation.expectationOrigins.originProfile = minimock.CallerInfo(1)

	return mmSignIn
}

// ExpectChallengeParam3 sets up expected param challenge for AuthSvc.SignIn
func (mmSignIn *mAuthSvcMockSignIn) ExpectChallengeParam3(challenge string) *mAuthSvcMockSignIn {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthSvcMock.SignIn mock is already set by Set")
	}

	if mmSignIn.defaultExpectation == nil {
		mmSignIn.defaultExpectation = &AuthSvcMockSignInExpectation{}
	}

	if mmSignIn.defaultExpectation.params != nil {
		mmSignIn.mock.t.Fatalf("AuthSvcMock.SignIn mock is already set by Expect")
	}

	if mmSignIn.defaultExpectation.paramPtrs == nil {
		mmSignIn.defaultExpectation.paramPtrs = &AuthSvcMockSignInParamPtrs{}
	}
	mmSignIn.defaultExpectation.paramPtrs.challenge = &challenge
	mmSignIn.defaultExpectation.expectationOrigins.originChallenge = minimock.CallerInfo(1)

	return mmSignIn
}

// Inspect accepts an inspector function that has same arguments as the AuthSvc.SignIn
func (mmSignIn *mAuthSvcMockSignIn) Inspect(f func(ctx context.Context, profile models.Profile, challenge string)) *mAuthSvcMockSignIn {
	if mmSignIn.mock.inspectFuncSignIn != nil {
		mmSignIn.mock.t.Fatalf("Inspect function is already set for AuthSvcMock.SignIn")
	}

	mmSignIn.mock.inspectFuncSignIn = f

	return mmSignIn
}

// Return sets up results that will be returned by AuthSvc.SignIn
func (mmSignIn *mAuthSvcMockSignIn) Return(token string, refresh string, err error) *AuthSvcMock {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthSvcMock.SignIn mock is already set by Set")
	}

	if mmSignIn.defaultExpectation == nil {
		mmSignIn.defaultExpectation = &AuthSvcMockSignInExpectation{mock: mmSignIn.mock}
	}
	mmSignIn.defaultExpectation.results = &AuthSvcMockSignInResults{token, refresh, err}
	mmSignIn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSignIn.mock
}

// Set uses given function f to mock the AuthSvc.SignIn method
func (mmSignIn *mAuthSvcMockSignIn) Set(f func(ctx context.Context, profile models.Profile, challenge string) (token string, refresh string, err error)) *AuthSvcMock {
	if mmSignIn.defaultExpectation != nil {
		mmSignIn.mock.t.Fatalf("Default expectation is already set for the AuthSvc.SignIn method")
	}

	if len(mmSignIn.expectations) > 0 {
		mmSignIn.mock.t.Fatalf("Some expectations are already set for the AuthSvc.SignIn method")
	}

	mmSignIn.mock.funcSignIn = f
	mmSignIn.mock.funcSignInOrigin = minimock.CallerInfo(1)
	return mmSignIn.mock
}

// When sets expectation for the AuthSvc.SignIn which will trigger the result defined by the following
// Then helper
func (mmSignIn *mAuthSvcMockSignIn) When(ctx context.Context, profile models.Profile, challenge string) *AuthSvcMockSignInExpectation {
	if mmSignIn.mock.funcSignIn != nil {
		mmSignIn.mock.t.Fatalf("AuthSvcMock.SignIn mock is already set by Set")
	}

	expectation := &AuthSvcMockSignInExpectation{
		mock:               mmSignIn.mock,
		params:             &AuthSvcMockSignInParams{ctx, profile, challenge},
		expectationOrigins: AuthSvcMockSignInExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSignIn.expectations = append(mmSignIn.expectations, expectation)
	return expectation
}

// Then sets up AuthSvc.SignIn return parameters for the expectation previously defined by the When method
func (e *AuthSvcMockSignInExpectation) Then(token string, refresh string, err error) *AuthSvcMock {
	e.results = &AuthSvcMockSignInResults{token, refresh, err}
	return e.mock
}

// Times sets number of times AuthSvc.SignIn should be invoked
func (mmSignIn *mAuthSvcMockSignIn) Times(n uint64) *mAuthSvcMockSignIn {
	if n == 0 {
		mmSignIn.mock.t.Fatalf("Times of AuthSvcMock.SignIn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSignIn.expectedInvocations, n)
	mmSignIn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSignIn
}

func (mmSignIn *mAuthSvcMockSignIn) invocationsDone() bool {
	if len(mmSignIn.expectations) == 0 && mmSignIn.defaultExpectation == nil && mmSignIn.mock.funcSignIn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSignIn.mock.afterSignInCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSignIn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SignIn implements mm_handler.AuthSvc
func (mmSignIn *AuthSvcMock) SignIn(ctx context.Context, profile models.Profile, challenge string) (token string, refresh string, err error) {
	mm_atomic.AddUint64(&mmSignIn.beforeSignInCounter, 1)
	defer mm_atomic.AddUint64(&mmSignIn.afterSignInCounter, 1)

	mmSignIn.t.Helper()

	if mmSignIn.inspectFuncSignIn != nil {
		mmSignIn.inspectFuncSignIn(ctx, profile, challenge)
	}

	mm_params := AuthSvcMockSignInParams{ctx, profile, challenge}

	// Record call args
	mmSignIn.SignInMock.mutex.Lock()
	mmSignIn.SignInMock.callArgs = append(mmSignIn.SignInMock.callArgs, &mm_params)
	mmSignIn.SignInMock.mutex.Unlock()

	for _, e := range mmSignIn.SignInMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.token, e.results.refresh, e.results.err
		}
	}

	if mmSignIn.SignInMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignIn.SignInMock.defaultExpectation.Counter, 1)
		mm_want := mmSignIn.SignInMock.defaultExpectation.params
		mm_want_ptrs := mmSignIn.SignInMock.defaultExpectation.paramPtrs

		mm_got := AuthSvcMockSignInParams{ctx, profile, challenge}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSignIn.t.Errorf("AuthSvcMock.SignIn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignIn.SignInMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.profile != nil && !minimock.Equal(*mm_want_ptrs.profile, mm_got.profile) {
				mmSignIn.t.Errorf("AuthSvcMock.SignIn got unexpected parameter profile, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignIn.SignInMock.defaultExpectation.expectationOrigins.originProfile, *mm_want_ptrs.profile, mm_got.profile, minimock.Diff(*mm_want_ptrs.profile, mm_got.profile))
			}

			if mm_want_ptrs.challenge != nil && !minimock.Equal(*mm_want_ptrs.challenge, mm_got.challenge) {
				mmSignIn.t.Errorf("AuthSvcMock.SignIn got unexpected parameter challenge, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignIn.SignInMock.defaultExpectation.expectationOrigins.originChallenge, *mm_want_ptrs.challenge, mm_got.challenge, minimock.Diff(*mm_want_ptrs.challenge, mm_got.challenge))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignIn.t.Errorf("AuthSvcMock.SignIn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSignIn.SignInMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignIn.SignInMock.defaultExpectation.results
		if mm_results == nil {
			mmSignIn.t.Fatal("No results are set for the AuthSvcMock.SignIn")
		}
		return (*mm_results).token, (*mm_results).refresh, (*mm_results).err
	}
	if mmSignIn.funcSignIn != nil {
		return mmSignIn.funcSignIn(ctx, profile, challenge)
	}
	mmSignIn.t.Fatalf("Unexpected call to AuthSvcMock.SignIn. %v %v %v", ctx, profile, challenge)
	return
}

// SignInAfterCounter returns a count of finished AuthSvcMock.SignIn invocations
func (mmSignIn *AuthSvcMock) SignInAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignIn.afterSignInCounter)
}

// SignInBeforeCounter returns a count of AuthSvcMock.SignIn invocations
func (mmSignIn *AuthSvcMock) SignInBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignIn.beforeSignInCounter)
}

// Calls returns a list of arguments used in each call to AuthSvcMock.SignIn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignIn *mAuthSvcMockSignIn) Calls() []*AuthSvcMockSignInParams {
	mmSignIn.mutex.RLock()

	argCopy := make([]*AuthSvcMockSignInParams, len(mmSignIn.callArgs))
	copy(argCopy, mmSignIn.callArgs)

	mmSignIn.mutex.RUnlock()

	return argCopy
}

// MinimockSignInDone returns true if the count of the SignIn invocations corresponds
// the number of defined expectations
func (m *AuthSvcMock) MinimockSignInDone() bool {
	if m.SignInMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SignInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SignInMock.invocationsDone()
}

// MinimockSignInInspect logs each unmet expectation
func (m *AuthSvcMock) MinimockSignInInspect() {
	for _, e := range m.SignInMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthSvcMock.SignIn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSignInCounter := mm_atomic.LoadUint64(&m.afterSignInCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SignInMock.defaultExpectation != nil && afterSignInCounter < 1 {
		if m.SignInMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthSvcMock.SignIn at\n%s", m.SignInMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthSvcMock.SignIn at\n%s with params: %#v", m.SignInMock.defaultExpectation.expectationOrigins.origin, *m.SignInMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignIn != nil && afterSignInCounter < 1 {
		m.t.Errorf("Expected call to AuthSvcMock.SignIn at\n%s", m.funcSignInOrigin)
	}

	if !m.SignInMock.invocationsDone() && afterSignInCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthSvcMock.SignIn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SignInMock.expectedInvocations), m.SignInMock.expectedInvocationsOrigin, afterSignInCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthSvcMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateProfileInspect()

			m.MinimockGetAccountByUserNameInspect()

			m.MinimockGetChallengeInspect()

			m.MinimockSignInInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthSvcMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthSvcMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateProfileDone() &&
		m.MinimockGetAccountByUserNameDone() &&
		m.MinimockGetChallengeDone() &&
		m.MinimockSignInDone()
}
